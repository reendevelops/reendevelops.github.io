<! DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="../css/content.css">

</head>

<body>
    <div class="background">

        <h1>Begin the journey!1</h1>
        <p id="mousePos">Mouse pos: </p>
        <p id="mouseTest">Mouse press: </p>
        <p id="position">Circle position: </p>
        <p id="log">Log: </p>

        <canvas id="mainCanvas" width="1920" height="1080"></canvas>

        <script>
            const canvas = document.getElementById("mainCanvas");
            const canvasWidth = 1920;
            const canvasHeight = 1080;
            const aspectRatio = canvasWidth / canvasHeight; // your fixed ratio (e.g., 800x450)
            const ctx = canvas.getContext("2d");


            // Define a Scene.
            class Scene {
                constructor(id) {
                    this.id = id;
                }

                // A scene must contain these variables:
                // Background image URL.
                background_image = "../img/journey1.png";

                // List of Hitboxes/Triggers to render.
                list_hitboxes = [];

                // List of active Triggers for tracking.
                list_activeTriggers = [];

                // Dictionary of 'entry points' with specific id.
                dict_entryPoints = {};
            }

            // Define a Vector2.
            class Vector2 {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                }
            }

            // Define a rect for hitboxes.
            class Hitbox {
                constructor(id, x, y, width, height, color, isCollider) {
                    this.id = id;
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.color = color;
                    this.isCollider = isCollider;
                    this.upperEdge = this.y;
                    this.lowerEdge = this.y + this.height;
                    this.leftEdge = this.x;
                    this.rightEdge = this.x + this.width;
                    this.upperEdgePos = { x: this.x, y: this.upperEdge };
                    this.lowerEdgePos = { x: this.x, y: this.lowerEdge };
                    this.leftEdgePos = { x: this.leftEdge, y: this.y };
                    this.rightEdgePos = { x: this.rightEdge, y: this.y };
                }
            };

            // Define an animated image class.
            class Animation {
                constructor(animationSpeed) {
                    this.frames = [];
                    this.animationSpeed = animationSpeed;
                }
            }


            // [ SCENES ]
            const list_scenes = [];

            // Create Scene 1.
            const scene_1 = new Scene("scene_1");
            scene_1.background_image = "../img/journey1.png";
            scene_1.list_hitboxes.push(new Hitbox("upperWall_1", 0, 0, 1920, 400, "black", true));
            scene_1.list_hitboxes.push(new Hitbox("trigger_to_scene_2", 1800, 460, 100, 300, "blue", false));
            scene_1.dict_entryPoints["spawn"] = new Vector2(950, 600);
            scene_1.dict_entryPoints["from_scene_2"] = new Vector2(1700, 600);
            list_scenes.push(scene_1);

            // Create Scene 2.
            const scene_2 = new Scene("scene_2");
            scene_2.background_image = "../img/journey1.png";
            scene_2.list_hitboxes.push(new Hitbox("upperWall_1", 0, 0, 1920, 360, "black", true));
            scene_2.list_hitboxes.push(new Hitbox("upperWall_2", 0, 700, 1920, 380, "black", true));
            scene_2.list_hitboxes.push(new Hitbox("trigger_test", 550, 355, 300, 50, "blue", false));
            scene_2.list_hitboxes.push(new Hitbox("trigger_to_spawn", 60, 380, 100, 300, "blue", false));
            scene_2.dict_entryPoints["spawn"] = new Vector2(200, 600);
            list_scenes.push(scene_2);

            // A temporary variable to refer to the current scene active.
            let active_scene = scene_1;

            // Active Scene reference variables.
            let list_hitboxes = active_scene.list_hitboxes;
            let list_activeTriggers = active_scene.list_activeTriggers;
            const active_backgroundImage = new Image();

            // Set background to initial Scene.
            active_backgroundImage.src = active_scene.background_image;


            // Starting position.
            let playerPos = new Vector2(active_scene.dict_entryPoints["spawn"].x, active_scene.dict_entryPoints["spawn"].y);
            let moveSpeed = 400;

            // Mouse position.
            let mousePos = new Vector2(0, 0);
            let isPressed = false;

            // Destination position.
            let destination = new Vector2(playerPos.x, playerPos.y);
            let distanceAllowance = 10; // how close is close enough


            // Load the RIGHT player animation frames.
            const playerImage_r1 = new Image();
            const playerImage_r2 = new Image();
            const playerImage_r3 = new Image();
            const playerImage_r4 = new Image();
            playerImage_r1.src = "../img/player_r1.png";
            playerImage_r2.src = "../img/player_r2.png";
            playerImage_r3.src = "../img/player_r3.png";
            playerImage_r4.src = "../img/player_r4.png";
            playerImage_r1.onload = function () { requestAnimationFrame(update); };
            playerImage_r2.onload = function () { requestAnimationFrame(update); };
            playerImage_r3.onload = function () { requestAnimationFrame(update); };
            playerImage_r4.onload = function () { requestAnimationFrame(update); };
            // Create the animation object.
            const playerAnim_r = new Animation(0.2);
            playerAnim_r.frames.push(playerImage_r1);
            playerAnim_r.frames.push(playerImage_r2);
            playerAnim_r.frames.push(playerImage_r3);
            playerAnim_r.frames.push(playerImage_r4);

            // Load the LEFT player animation frames.
            const playerImage_l1 = new Image();
            const playerImage_l2 = new Image();
            const playerImage_l3 = new Image();
            const playerImage_l4 = new Image();
            playerImage_l1.src = "../img/player_l1.png";
            playerImage_l2.src = "../img/player_l2.png";
            playerImage_l3.src = "../img/player_l3.png";
            playerImage_l4.src = "../img/player_l4.png";
            playerImage_l1.onload = function () { requestAnimationFrame(update); };
            playerImage_l2.onload = function () { requestAnimationFrame(update); };
            playerImage_l3.onload = function () { requestAnimationFrame(update); };
            playerImage_l4.onload = function () { requestAnimationFrame(update); };
            // Create the animation object.
            const playerAnim_l = new Animation(0.2);
            playerAnim_l.frames.push(playerImage_l1);
            playerAnim_l.frames.push(playerImage_l2);
            playerAnim_l.frames.push(playerImage_l3);
            playerAnim_l.frames.push(playerImage_l4);


            // Detect mouse movement.
            canvas.addEventListener("mousemove", (event) => {
                const rect = canvas.getBoundingClientRect(); // Canvas position on page.

                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                mousePos.x = (event.clientX - rect.left) * (canvasWidth / rect.width);
                mousePos.y = (event.clientY - rect.top) * (canvasHeight / rect.height);

                document.getElementById("mousePos").innerHTML = "Mouse pos: " + mousePos.x + ", " + mousePos.y;
            });

            // Detect mouse press.
            canvas.addEventListener("mousedown", () => {
                isPressed = true;

                // Set destination on click.
                const rect = canvas.getBoundingClientRect(); // Canvas position on page.

                destination.x = (event.clientX - rect.left) * (canvasWidth / rect.width);
                destination.y = (event.clientY - rect.top) * (canvasHeight / rect.height);

                document.getElementById("mouseTest").innerHTML = "Mouse press: " + destination.x + ", " + destination.y;
            });

            // Detect mouse release.
            canvas.addEventListener("mouseup", () => {
                isPressed = false;
            });


            // Time tracker.
            let lastTime = performance.now();

            // Update loop.
            function update(currentTime) {
                const deltaTime = (currentTime - lastTime) / 1000; // seconds
                lastTime = currentTime;

                // Resize canvas.
                resizeCanvas();

                // Clear the previous frame.
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw the background image of the Scene.
                ctx.drawImage(active_backgroundImage, 0, 0, canvas.width, canvas.height);

                // Everything drawn now scales perfectly.
                const scaleX = canvas.width / canvasWidth;
                const scaleY = canvas.height / canvasHeight;
                ctx.save();
                ctx.scale(scaleX, scaleY); 

                // Move the player towards destination.
                movePlayer(destination, deltaTime);

                document.getElementById("position").innerHTML = "Player position: " + playerPos.x + ", " + playerPos.y;

                // Detect if player ACTIVATES a Trigger hitbox.
                if (isInsideAHitbox(playerPos)) {
                    let hitbox = getHitboxFromHere(playerPos);

                    // Activate if a Trigger.
                    if (!hitbox.isCollider) {

                        // Activate whatever result the Trigger does according to its ID.
                        activateThisTrigger(hitbox);
                    }
                }

                // Detect if player DEACTIVATES a Trigger hitbox.
                for (let i = 0; i < list_activeTriggers.length; i++) {
                    let trigger = list_activeTriggers[i];

                    // Check each active Trigger if player is no longer on it.
                    if (!isInsideHitbox(trigger, playerPos)) {
                        // Remove from active list and DISABLE it.
                        list_activeTriggers.splice(i, 1);
                        trigger.color = "blue";
                    }
                }

                // Prevent the player from passing through Collider hitboxes.
                if (isInsideACollider(playerPos)) {
                    let hitbox = getHitboxFromHere(playerPos);

                    // Set the new playerPos.
                    playerPos = getPositionOutsideHitbox(hitbox, playerPos);
                }

                // If player is heading left.
                if (destination.x < playerPos.x)
                    ctx.drawImage(playerImage_l1, playerPos.x - playerImage_l1.width / 4, playerPos.y - playerImage_l1.height / 2.5, playerImage_l1.width / 2, playerImage_l1.height / 2);
                else
                    ctx.drawImage(playerImage_r1, playerPos.x - playerImage_r1.width / 4, playerPos.y - playerImage_r1.height / 2.5, playerImage_r1.width / 2, playerImage_r1.height / 2);

                // Draw a circle following the mouse
                ctx.beginPath();
                ctx.arc(mousePos.x, mousePos.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(232, 100, 27, 0.5)";
                ctx.fill();

                // Draw the hitboxes.
                drawAllHitbox();

                // Draw the current Scene's entry points.
                drawSceneEntryPoints();

                // For the scaling.
                ctx.restore();

                // Call update() again for the next frame.
                requestAnimationFrame(update);
            }


            // Move the player towards this destination.
            function movePlayer(destination, deltaTime) {

                // Always move the player towards the destination
                const dx = destination.x - playerPos.x;
                const dy = destination.y - playerPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Move playerPos toward destination if not too close
                if (distance > distanceAllowance) {
                    const dirX = dx / distance;
                    const dirY = dy / distance;

                    const step = moveSpeed * deltaTime;

                    playerPos.x += dirX * step;
                    playerPos.y += dirY * step;
                }
            }

            // Change the Scene to this.
            function changeScene(scene, entryPointID) {
                // Play a transition cover.

                // Change background.
                active_backgroundImage.src = scene.background_image;

                // Change all Hitboxes/Triggers. (Seems to have done it automatically)
                list_hitboxes = scene.list_hitboxes;
                list_activeTriggers = scene.list_activeTriggers;

                // Move the player to the starting position of that Scene.
                playerPos = new Vector2(scene.dict_entryPoints[entryPointID].x, scene.dict_entryPoints[entryPointID].y);

                // Stop movement by clearing destination.
                destination = new Vector2(playerPos.x + distanceAllowance, playerPos.y);

                // Deactivate all Triggers of the previous Scene.
                active_scene.list_activeTrigger = [];

                // Change the active scene variable.
                active_scene = scene;
            }

            // Activate a specific event for each Trigger.
            function activateThisTrigger(trigger) {
                // Go through all IDs.
                if (trigger.id == "trigger_to_scene_2") {
                    changeScene(scene_2, "spawn");
                }
                else if (trigger.id == "trigger_to_spawn") {
                    changeScene(scene_1, "from_scene_2");
                }

                trigger.color = "pink";
                // Add this Trigger to the activated list to check for DEACTIVATION.
                list_activeTriggers.push(trigger);
            }

            function log(text) {
                document.getElementById("log").innerHTML = "Log: " + text;
            }


            // Draw ALL hitboxes.
            function drawAllHitbox() {
                for (let i = 0; i < list_hitboxes.length; i++) {
                    let hitbox = list_hitboxes[i];

                    // Adjust colors and width for each hitbox.
                    ctx.strokeStyle = hitbox.color;
                    ctx.lineWidth = 2;

                    ctx.strokeRect(hitbox.x, hitbox.y, hitbox.width, hitbox.height);
                }
            }

            // Draw ALL entry points of the current Scene.
            function drawSceneEntryPoints() {
                for (const [key, value] of Object.entries(active_scene.dict_entryPoints)) {
                    // Set the default colors of entry points.
                    ctx.strokeStyle = "green";
                    ctx.lineWidth = 2;

                    ctx.strokeRect(value.x, value.y, 50, 50);
                }
            }

            // Return what player animation frame should be drawn.
            function getPlayerImage(xDestination, xPlayerPos) {
                if (xDestination < xPlayerPos) {

                }
            }

            // Checks if inside ANY hitbox.
            function isInsideAHitbox(canvasPos) {
                for (let i = 0; i < list_hitboxes.length; i++) {
                    let hitbox = list_hitboxes[i];
                    if (isInsideHitbox(hitbox, canvasPos))
                        return true;
                }
                return false;
            }

            // Checks if inside ANY COLLIDER hitbox.
            function isInsideACollider(canvasPos) {
                for (let i = 0; i < list_hitboxes.length; i++) {
                    let hitbox = list_hitboxes[i];
                    if (isInsideHitbox(hitbox, canvasPos) && hitbox.isCollider)
                        return true;
                }
                return false;
            }

            // Checks if inside a SPECIFIC hitbox.
            function isInsideHitbox(hitbox, canvasPos) {
                if (canvasPos.x < hitbox.rightEdge && canvasPos.x > hitbox.leftEdge)
                    if (canvasPos.y > hitbox.upperEdge && canvasPos.y < hitbox.lowerEdge)
                        return true;
                return false;
            }

            // Returns the hitbox if inside it.
            function getHitboxFromHere(canvasPos) {
                for (let i = 0; i < list_hitboxes.length; i++) {
                    let hitbox = list_hitboxes[i];
                    if (isInsideHitbox(hitbox, canvasPos))
                        return hitbox;
                }
                return null;
            }

            // KNOWN BUGS:
            // Trigger is not triggered when 
            function getPositionOutsideHitbox(hitbox, originalPos) {
                // Get closest edge from originalPos.
                let closestEdgePos = { x: originalPos.x, y: hitbox.upperEdgePos.y };

                // Lower
                let lowerEdgePos = { x: originalPos.x, y: hitbox.lowerEdgePos.y };
                if (distance(originalPos, closestEdgePos) > distance(originalPos, lowerEdgePos))
                    closestEdgePos = lowerEdgePos;

                // Left
                let leftEdgePos = { x: hitbox.leftEdgePos.x, y: originalPos.y };
                if (distance(originalPos, closestEdgePos) > distance(originalPos, leftEdgePos))
                    closestEdgePos = leftEdgePos;

                // Right
                let rightEdgePos = { x: hitbox.rightEdgePos.x, y: originalPos.y };
                if (distance(originalPos, closestEdgePos) > distance(originalPos, rightEdgePos))
                    closestEdgePos = rightEdgePos;

                return closestEdgePos;
            }



            function distance(a, b) {
                let dx = b.x - a.x;
                let dy = b.y - a.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function resizeCanvas() {
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const windowRatio = windowWidth / windowHeight;

                if (windowRatio > aspectRatio) {
                    // Window is wider than your ratio = match height
                    canvas.height = windowHeight;
                    canvas.width = windowHeight * aspectRatio;
                } else {
                    // Window is taller than your ratio = match width
                    canvas.width = windowWidth;
                    canvas.height = windowWidth / aspectRatio;
                }

                // Center the canvas.
                canvas.style.position = "absolute";
                canvas.style.left = `${(windowWidth - canvas.width) / 2}px`;
                canvas.style.top = `${(windowHeight - canvas.height) / 2}px`;
            }

            // Start animation.
            update();
        </script>
    </div>

</body>
</html>
